# setting some default values
NOCOR=${NOCOR:-0}
NOMENU=${NOMENU:-0}
NOPRECMD=${NOPRECMD:-0}
COMMAND_NOT_FOUND=${COMMAND_NOT_FOUND:-0}
GRML_ZSH_CNF_HANDLER=${GRML_ZSH_CNF_HANDLER:-/usr/share/command-not-found/command-not-found}
BATTERY=${BATTERY:-0}
GRMLSMALL_SPECIFIC=${GRMLSMALL_SPECIFIC:-1}
GRML_ALWAYS_LOAD_ALL=${GRML_ALWAYS_LOAD_ALL:-0}
ZSH_NO_DEFAULT_LOCALE=${ZSH_NO_DEFAULT_LOCALE:-0}

#f2# Find history events by search pattern and list them by date.
whatwhen()  {
    emulate -L zsh
    local usage help ident format_l format_s first_char remain first last
    usage='USAGE: whatwhen [options] <searchstring> <search range>'
    #  help='Use' \`'whatwhen -h'\'' for further explanations.' # no idea why this doesn't work --obreitwi, 21-06-10 17:37:19
    ident=${(l,${#${:-Usage: }},, ,)}
    format_l="${ident}%s\t\t\t%s\n"
    format_s="${format_l//(\\t)##/\\t}"
    # Make the first char of the word to search for case
    # insensitive; e.g. [aA]
    first_char=[${(L)1[1]}${(U)1[1]}]
    remain=${1[2,-1]}
    # Default search range is `-1000'.
    first=${2:-\-1000}
    # Optional, just used for `<first> <last>' given.
    last=$3
    case $1 in
        ("")
            printf '%s\n\n' 'ERROR: No search string specified. Aborting.'
            printf '%s\n%s\n\n' ${usage} ${help} && return 1
        ;;
        (-h)
            printf '%s\n\n' ${usage}
            print 'OPTIONS:'
            printf $format_l '-h' 'show help text'
            print '\f'
            print 'SEARCH RANGE:'
            printf $format_l "'0'" 'the whole history,'
            printf $format_l '-<n>' 'offset to the current history number; (default: -100)'
            printf $format_s '<[-]first> [<last>]' 'just searching within a give range'
            printf '\n%s\n' 'EXAMPLES:'
            printf ${format_l/(\\t)/} 'whatwhen grml' '# Range is set to -1000 by default.'
            printf $format_l 'whatwhen zsh -250'
            printf $format_l 'whatwhen foo 1 99'
        ;;
        (\?)
            printf '%s\n%s\n\n' ${usage} ${help} && return 1
        ;;
        (*)
            # -l list results on stout rather than invoking $EDITOR.
            # -i Print dates as in YYYY-MM-DD.
            # -m Search for a - quoted - pattern within the history.
            fc -li -m "*${first_char}${remain}*" $first $last
        ;;
    esac
# }}}
}

# It's shameless stolen from <http://www.vim.org/tips/tip.php?tip_id=167>
#f5# Use \kbd{vim} as your manpage reader
vman() {
    emulate -L zsh
    man $* | col -b | view -c 'set ft=man nomod nolist' -
}

multicat() {
    for fname in $*; do
        for count in {0..$(( ${#fname} + 9 ))};do
            echo -n "#"
        done
        echo ""
        echo "# FILE: $fname #"
        for count in {0..$(( ${#fname} + 9 ))};do
            echo -n "#"
        done
        echo ""
        cat $fname
    done
}
zle -N multicat

setkipproxy() {
    export no_proxy="localhost,127.0.0.1,.kip.uni-heidelberg.de"
    export http_proxy=http://proxy2.kip.uni-heidelberg.de:8080
    export ftp_proxy=http://proxy2.kip.uni-heidelberg.de:21
    export https_proxy=http://proxy2.kip.uni-heidelberg.de:8080
}
zle -N setkipproxy


setnoproxy() {
    unset no_proxy
    unset http_proxy
    unset ftp_proxy
    unset https_proxy
}
zle -N setnoproxy

# print all arguments on new lines
printl() {
    for a in "$@"; do echo $a; done
}
zle -N printl

# print all arguments with pwd prepended
printp() {
    for a in "$@"; do echo $(pwd -P)/$a; done
}
zle -N printp
#
# print all arguments with custom prefix
printc() {
    for a in "${@:2}"; do echo $1/$a; done
}
zle -N printc

# cp a file, inserting the directory name into the real filename
# (implemented in python now)
# cpd () {
    # SRC=$1
    # TARGET_FOLDER=$2
    # filename=$(basename $SRC)
    # last_dir=$(basename $(dirname $SRC))
    # cp -v ${SRC} ${TARGET_FOLDER}/${last_dir}_${filename}
# }


# generate a random string of length $1
rstr() {
    if [[ $# > 0 ]]; then
        strlen="$1"
    else
        strlen="8"
    fi
    cat /dev/urandom 2>/dev/null | tr -cd "[:alnum:]" 2>/dev/null | head -c ${strlen}
}
zle -N rstr


popen() {
    if [[ $# == 0 ]]; then
        ilab -ic "import cPickle as pickle";
    elif [[ $# == 1 ]]; then
        ipython -ic "import cPickle as pickle; ${1:t:r} = pickle.load( open( '${1}', 'r' ))"
    else
        ipython -ic "import cPickle as pickle; ${2} = pickle.load( open( '${1}', 'r' ))"
    fi
}
zle -N popen

foreground-vim() {
    fg %vim
    fg %nvim
}
zle -N foreground-vim
bindkey '^Z' foreground-vim

find_in_hist() {
    zgrep -i "$1" ~/.logs/*.gz
    grep -ri "$1" ~/.logs
}
alias fih=find_in_list

tmux-launch-and-configure() {
    tmux new-session -d -s $1
    tmux source "$HOME/.tmux/$1.conf"
    tmux attach -t $1
}

get-modeline() {
    cvt $1 $2 $3 | grep Modeline | sed -e "s/Modeline\s//"
}

slurm-get-job-ids() {
    if [[ $# > 1 ]]; then
        state=$1
    else
        state="PD"
    fi
    squeue -h | grep obreitwi | grep "\b$state\b" | cut -d " " -f 3
}

# nicer git log
gitlg() {
    PAGER=/usr/bin/less git log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit $@ --
}

heic_to_jpg() {
    for origin in "$@"; do
        extension=${origin:e}
        if [[ "${extension:l}" != "heic" ]]; then
            echo "Wrong extension: ${origin}" >&2
        else
            target="${origin:r}.jpg"
            tifig -v -p -q 95 -i ${origin} -o ${target}
        fi
    done
}

svg_to_pdf() {
    for origin in "$@"; do
        extension=${origin:e}
        if [[ "$extension" != "svg" ]]; then
            echo "Wrong extension: ${origin}" >&2
        else
            target="${origin:r}.pdf"
            inkscape --export-pdf="$target" --export-dpi=600 --export-area-page  $origin
        fi
    done
}

svg_to_png() {
    for origin in "$@"; do
        extension=${origin:e}
        if [[ "$extension" != "svg" ]]; then
            echo "Wrong extension: ${origin}" >&2
        else
            target="${origin:r}.png"
            inkscape --export-png="$target" --export-dpi=600 --export-area-page  $origin
        fi
    done
}

# see https://trac.ffmpeg.org/wiki/Encode/MP3
to_mp3() {
    for origin in "$@"; do
        ffmpeg -i "${origin}" -vn -acodec libmp3lame -ac 2 -aq ${AQ:-2} -ar 48000 "${origin:t:r}.mp3"
    done
}

get_eta() {
    for f in "$@"; do
        grep "ETA" $f | tail -n 1
    done
}

uniq_lines() {
    cat -n $1 | sort -uk2 | sort -nk1 | cut -f2-
}

spack_modules() {
    TMPFILE="$(mktemp)"
    for mod in "$@"; do
        (echo "Loading $mod…" 1>&2)
        spack module loads -r $mod >> $TMPFILE
    done
    (echo "Committing…" 1>&2)
    uniq_lines $TMPFILE
    rm $TMPFILE
}

eg () {
        (( $+1 )) || {
                cat >&2 <<END
Usage: $0 [<args>...] [<expr>]

  args: Arguments to pass to man.
  expr: Command line argument to search for.
        Defaults to jump to the "EXAMPLE" section.

Examples:

  $0 find
  $0 less -s
  $0 1 less -s
  $0 zshall HIST_IGNORE_SPACE
  $0 zshall fc
END
                return 1
        }
        local expr='^EXAMPLE'
        local -a args
        args=("$@")
        (( $+2 )) && {
                expr="^[[:blank:]]*${@[-1]}"
                args=("${@[1,-2]}")
        }
        PAGER="less -g -s '+/$expr'" man "${=args}"
}

spack_load() {
    source =(spack_modules "$@")
}

cat_pkl() {
    for f in "$@"; do
        python -c "import cPickle as pkl, pprint; pprint.pprint(pkl.load(open('${f}', 'r')))"
    done
}

# Fetch all open changesets and assign them their own branch:
# gerrit_tree_view/{change number}/{patchset level}
gerrit_fetch_changesets() {
    git_dir="$(git rev-parse --show-toplevel)"
    # remote branch
    gerrit_remote="$(grep "^defaultremote=" "${git_dir}/.gitreview" | cut -d = -f 2)"
    localbranchname=gerrit_tree_view

    gerrit_remote_raw=$(git config --local remote.${gerrit_remote}.url)
    elements=("${(@s:/:)gerrit_remote_raw}")
    gerrit_project=${elements[-1]}
    elements[-1]=()
    gerrit_url=${(j./.)elements}

    elements=("${(@s.:.)gerrit_url}")
    gerrit_port=${elements[-1]}
    gerrit_url=${${elements[-2]}:gs./.}

    git branch -D $(git branch | grep "$localbranchname") &> /dev/null
    ssh -p ${gerrit_port} ${gerrit_url} gerrit query "project:${gerrit_project} status:open" --current-patch-set | sed -n 's/\s*ref: //p' | while read REF
do
    git fetch "${gerrit_remote}" "${REF}"
    git branch $(echo "${REF}" | sed "s#refs/changes/../#${localbranchname}/#") FETCH_HEAD
done
}

gerrit_query() {
    local git_dir gerrit_branch gerrit_remote gerrit_host gerrit_port gerrit_project

    git_dir="$(git rev-parse --show-toplevel)"

    gerrit_branch="$(grep "^defaultbranch=" "${git_dir}/.gitreview" | cut -d = -f 2)"
    gerrit_remote="$(grep "^defaultremote=" "${git_dir}/.gitreview" | cut -d = -f 2)"
    gerrit_host="$(grep "^host=" "${git_dir}/.gitreview" | cut -d = -f 2)"
    gerrit_port="$(grep "^port=" "${git_dir}/.gitreview" | cut -d = -f 2)"
    gerrit_project="$(grep "^project=" "${git_dir}/.gitreview" | cut -d = -f 2)"

    ssh -p ${gerrit_port} ${gerrit_host} gerrit query "${@}"
}

# Get current change ids
#
# Usage:
#   gerrit_current_change_ids [-b <base-commit>]
#
#   -b defaults to remote head
gerrit_current_change_ids() {
    git_dir="$(git rev-parse --show-toplevel)"
    local base_commit=""

    local opts OPTIND OPTARG
    while getopts ":b:" opts; do
        case "${opts}" in
            b)
                base_commit="${OPTARG}"
                ;;
            *)
                echo "Invalid argument: ${opts}" >&2
                return 1
                ;;
        esac
    done
    shift $(( OPTIND - 1 ))

    if [ -z "${base_commit}" ]; then
        # remote branch
        gerrit_branch="$(grep "^defaultbranch=" "${git_dir}/.gitreview" | cut -d = -f 2)"
        gerrit_remote="$(grep "^defaultremote=" "${git_dir}/.gitreview" | cut -d = -f 2)"

        gerrit_remote_raw=$(git config --local remote.${gerrit_remote}.url)
        elements=("${(@s:/:)gerrit_remote_raw}")
        gerrit_project=${elements[-1]}
        elements[-1]=()
        gerrit_url=${(j./.)elements}

        elements=("${(@s.:.)gerrit_url}")
        gerrit_port=${elements[-1]}
        gerrit_url=${${elements[-2]}:gs./.}

        base_commit="${gerrit_remote}/${gerrit_branch}"
    fi
    change_ids=( "${(@f)$(git log ${base_commit}..HEAD \
        | awk '$1 ~ /^Change-Id:/ { print $2 }')}" )

    printf "%s\n" "${change_ids[@]}"
}

# Check if the last patch level of any open changeset was last uploaded by someone else.
#
# This should make it harder to accidentally overwrite other peoples edits.
gerrit_check_pre_review() {
    git_dir="$(git rev-parse --show-toplevel)"
    # remote branch
    gerrit_branch="$(grep "^defaultbranch=" "${git_dir}/.gitreview" | cut -d = -f 2)"
    gerrit_remote="$(grep "^defaultremote=" "${git_dir}/.gitreview" | cut -d = -f 2)"

    gerrit_remote_raw=$(git config --local remote.${gerrit_remote}.url)
    elements=("${(@s:/:)gerrit_remote_raw}")
    gerrit_project=${elements[-1]}
    elements[-1]=()
    gerrit_url=${(j./.)elements}

    elements=("${(@s.:.)gerrit_url}")
    gerrit_port=${elements[-1]}
    gerrit_url=${${elements[-2]}:gs./.}
    change_ids=( "${(@f)$(gerrit_current_change_ids)}" )
    committers=( "${(@f)$(git log --format="%cn <%ce>" "${gerrit_remote}/${gerrit_branch}..HEAD")}" )

    if (( ${#change_ids} != ${#committers} )); then
        echo "Not all commits in question have Change-Ids!" >&2
        return 1
    fi

    gerrit_username="${${gerrit_url##ssh://}%%@*}"

    tmpfile_change_info="$(mktemp)"

    for ((i = 1; i <= ${#change_ids}; i++)); do
        change_id="${change_ids[$i]}"
        committer="${committers[$i]}"

        ssh -p ${gerrit_port} ${gerrit_url} \
            "gerrit query project:${gerrit_project} change:${change_id} status:open --current-patch-set --format JSON" \
            | head -n 1 > "${tmpfile_change_info}"
        uploader_name="$(jq -r ".currentPatchSet.uploader.name" < "${tmpfile_change_info}")"
        uploader_mail="$(jq -r ".currentPatchSet.uploader.email" < "${tmpfile_change_info}")"
        change_url="$(jq -r ".url" < "${tmpfile_change_info}")"

        uploader="${uploader_name} <${uploader_mail}>"

        if [[ "${uploader}" == "null <null>" ]]; then
            echo "WARNING: Info on changeset ${change_id} not current anymore! Fetch from review!" >&2
        fi

        if [[ "${committer}" != "${uploader}" ]]; then
            echo "WARNING: [${change_url}] Committers differ! Local: ${committer} / Gerrit: ${uploader}" >&2
        fi
    done
    rm "${tmpfile_change_info}"
}

gen_ssha512() {
    local pw="$1"
    while [ -z "${pw}" ]; do
        echo -n "Password: "
        read -s pw_1
        echo ""
        echo -n "Password (repeat): "
        read -s pw_2
        echo ""
        if [[ "${pw_1}" = "${pw_2}" ]] && [[ "${pw_2}" = "${pw_2}" ]]; then
            pw="${pw_1}"
        fi
    done
    local salt=$(cat /dev/urandom | head -c 8)
    (
        echo -n "${pw}${salt}" | openssl dgst -sha512 -binary
        echo -n ${salt}
    ) | openssl enc -a -A | awk '{ print "{SSHA512}"$0 }'
}

startx-wifi() {
    # start the xserver with a given wifi profile
    sudo netctl start "${1}" &; startx 
}

# container utility functions
# Usage:
#   launch_container [options] [<app>] [<image>]
launch_container() {
    local image
    local app

    local args
    args=("shell" "-s" "/bin/zsh")

    local getent_home
    getent_home=$(getent passwd $USER | cut -d: -f6)

    # if current $HOME differs from getent value, set it
    if [ "${HOME}" != "${getent_home}" ]; then
        args+=("-H" "${HOME}")
    fi

    args+=("-B" "/run")

    if (( $# > 0 )); then
        app="${1}"
        args+=("--app" "${app}")
        shift
    fi
    image="${1:-$(readlink -f ${MY_DEFAULT_CONTAINER:-/containers/stable/latest})}"

    singularity "${args[@]}" "${image}"
}

alias runcon="launch_container"

condev() {
    launch_container visionary-dev-tools "${@}"
}

conwaf() {
    launch_container visionary-wafer "${@}"
}

condls() {
    launch_container visionary-dls "${@}"
}

gerrit() {
  ssh -p $(jq -r .port ~/.config/gerrit/gerrit.json) \
      -l $(jq -r .username ~/.config/gerrit/gerrit.json) \
      $(jq -r .host.ssh ~/.config/gerrit/gerrit.json) gerrit "${@}"
}


# gerrit rest api access
# first argument an be used to specify the method, if it is not GET POST or PUT
# it will be interpreted as URL
grest() {
    local host
    local method
    local url
    local username
    local password
    method=$1
    if [[ "${(U)method}" =~ "^(GET|PUT|POST|DELETE)$" ]]; then
        shift
    else
        # first argument only contains URL
        method=""
    fi
    url=$1
    host="$(jq -r .host.web ~/.config/gerrit/gerrit.json)"
    username="$(jq -r .username ~/.config/gerrit/gerrit.json)"
    password="$(jq -r .password ~/.config/gerrit/gerrit.json)"
    shift
    http --auth-type basic                                                    \
         --auth "${username}:${password}"                                     \
         ${method}                                                            \
         ${host}${url}                                                        \
         "${@}"
}

jrest() {
    local method
    local url
    local username
    local password
    method=$1
    if [[ "${(U)method}" =~ "^(GET|PUT|POST|DELETE)$" ]]; then
        shift
    else
        # first argument only contains URL
        method=""
    fi
    url=$1
    host="$(jq -r .url ~/.config/jenkins/jenkins.json)"
    username="$(jq -r .username ~/.config/jenkins/jenkins.json)"
    token="$(jq -r .token ~/.config/jenkins/jenkins.json)"
    shift
    http --auth-type basic                                                   \
         --auth "${username}:${token}"                                       \
         ${method}                                                           \
         ${host}${url}                                                       \
         "${@}"
}

# Usage:
#   jenkins_get_log [-a <artifact>] <project>[/][<build number>]
#
#   Fetches and echoes the name of the file in which the log is present. Log
#   will only be fetched if logfile does not exist.
#
#   Can then be used like this: nvim $(jenkins_get_log my-fancy-jobname).
#
# Args:
#   -a <artifact>   Get specific artifact (example: errors_concretization.log).
#
#   -f              Force redownload of log even if it exists.
#
#   <project>       Project to fetch
#
#   <build number>  Log from which build to get [default: latest]. Can be set
#                   to -n to get the n-th latest build log.
#
jenkins_get_log() {
    local project
    local build_num
    local logname
    local artifact
    local force
    local latest_build
    local opts OPTIND OPTARG
    artifact=""
    force=0

    while getopts ":a:f" opts; do
        case "${opts}" in
            a)
                artifact="${OPTARG}"
                ;;
            f)  force=1
                ;;
            *)
                echo "Invalid argument: ${opts}" >&2
                return 1
                ;;
        esac
    done
    shift $(( OPTIND - 1 ))

    if (( $# > 0 )); then
        local proj_arr
        proj_arr=( "${(s./.)1}" )
        project="${proj_arr[1]}"
        if (( ${#proj_arr} > 1 )); then
            build_num="${proj_arr[2]}"
        fi
    else
        echo "Need to specify project!" &>2
        return 1
    fi
    shift

    if (( $# > 0 )); then
        build_num="$1"
        shift
    fi

    if [ -n "${build_num:-}" ]; then
        if (( build_num <= 0 )); then
            latest_build=$(jrest GET /job/${project}/api/json | jq ".builds | .[0] | .number")
            build_num=$(( latest_build + build_num ))
        fi
    else
        build_num=$(jrest GET /job/${project}/api/json | jq ".builds | .[0] | .number")
    fi
    if (( ${#artifact} > 0 )); then
        logname="${TMPDIR:-/tmp}/${project}_${build_num}_${artifact}"
    else
        logname="${TMPDIR:-/tmp}/${project}_${build_num}.log"
    fi

    if [ ! -f "${logname}" ] || (( force != 0 )); then
        if (( ${#artifact} > 0 )); then
            jrest GET "/job/${project}/${build_num}/artifact/${artifact}" > "${logname}" || rm ${logname}
        else
            jrest GET "/job/${project}/${build_num}/consoleText" > "${logname}"
        fi
    fi
    echo "${logname}"
}

gerrit_get_changes() {
    grest "/a/changes/?q=$*"  | tail -n +2 | jq -r "map(.id) | .[]"
}

clang_format_head() {
    file_list=("${(@f)$(git diff-tree ${1:-HEAD} --no-commit-id --name-only -r \
        | grep "\.\(c\|cpp\|tcc\|h\|hpp\)$" \
        | xargs ls -d 2>/dev/null \
        )}")
    clang-format -i "${file_list[@]}"
    sed -i "s:^\(} // namespace .*\)GENPYBIND_TAG_.*$:\1:" "${file_list[@]}"
    git status
}

gerrit_change_id_head()
{
    git log -n 1 | awk '$1 ~ /Change-Id:/ { print $2 }' | tr -d '\n'
}

# Post a message (-m) to the given change_id (-c)
#
# If change id is not specified, take the current head.
#
# Args:
#   -c change_id
#   -l labels
#   -m message
gerrit_post_message() {
    local change_id
    local message
    local labels
    local -a args
    local opts OPTIND OPTARG
    change_id="head"
    message=""
    while getopts ":c:l:m:" opts; do
        case "${opts}" in
            c)
                change_id="${OPTARG}"
                ;;
            m)  message="${OPTARG}"
                ;;
            l)  labels="${OPTARG}"
                ;;
            t)  topic="${OPTARG}"
                ;;
            *)
                echo "Invalid argument: ${opts}" >&2
                return 1
                ;;
        esac
    done
    shift $(( OPTIND - 1 ))

    if [ "${change_id}" = "head" ]; then
        change_id="$(gerrit_change_id_head)"
    fi

    args=( POST "/a/changes/${change_id}/revisions/current/review" )

    if [ -n "${message}" ]; then
        args+=( "message=${message}" )
    fi

    if [ -n "${labels}" ]; then
        args+=( "labels:=${labels}" )
    fi

    grest "${args[@]}"
}

# Set a topic (-t) on the given change_id (-c)
#
# If change id is not specified, take the current head.
#
# Args:
#   -c change_id
#   -t topic
gerrit_set_topic() {
    local change_id
    local topic
    local -a args
    local opts OPTIND OPTARG
    change_id="head"
    message=""
    while getopts ":c:t:" opts; do
        case "${opts}" in
            c)
                change_id="${OPTARG}"
                ;;
            t)  topic="${OPTARG}"
                ;;
            *)
                echo "Invalid argument: ${opts}" >&2
                return 1
                ;;
        esac
    done
    shift $(( OPTIND - 1 ))

    if [ "${change_id}" = "head" ]; then
        change_id="$(gerrit_change_id_head)"
    fi

    args=( PUT "/a/changes/${change_id}/topic" )

    if [ -n "${topic}" ]; then
        args+=( "topic=${topic}" )
    else
        echo "ERROR: -t not provided!" >&2
        exit 1
    fi

    grest "${args[@]}"
}

# Modify hashtags on the given change_id (-c)
#
# If change id is not specified, take the current head.
#
# Args:
#   -c change_id
#   [-a <hashtag to add>...]
#   [-r <hashtag to remove>...]
gerrit_hashtags() {
    local change_id
    local -a add
    local -a remove
    local -a args
    local opts OPTIND OPTARG
    change_id="head"
    while getopts ":c:a:r:" opts; do
        case "${opts}" in
            c)
                change_id="${OPTARG}"
                ;;
            a)  add+=("${OPTARG}")
                ;;
            r)  remove=+("${OPTARG}")
                ;;
            *)
                echo "Invalid argument: ${opts}" >&2
                return 1
                ;;
        esac
    done
    shift $(( OPTIND - 1 ))

    if [ "${change_id}" = "head" ]; then
        change_id="$(gerrit_change_id_head)"
    fi

    args=( POST "/a/changes/${change_id}/hashtags" )

    if [ -n "${add[*]}" ] && [ -n "${remove[*]}" ]; then
        echo "ERROR: No hashtags given." >&2
        exit 1
    fi

    if [ -n "${add[*]}" ]; then
        local add_inner="$(printf '"%s", ' "${add[@]}")"
        args+=( "add:=[${add_inner%%, }]" )
    fi

    if [ -n "${remove[*]}" ]; then
        local remove_inner="$(printf '"%s", ' "${remove[@]}")"
        args+=( "remove:=[${remove_inner%%, }]" )
    fi

    grest "${args[@]}"
}

gerrit_build_this() {
    gerrit_post_message -m "BUILD_THIS"
}

get_bpm() {
    sox "$1" -t raw -r 44100 -e float -c 1 - | bpm -x ${max_bpm:-190}
}

nv() {
    neovide "${@}" &|
}

# vim: ft=zsh
