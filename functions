source "$HOME/.zsh/functions.d/container.zsh"
source "$HOME/.zsh/functions.d/conversion.zsh"
source "$HOME/.zsh/functions.d/crypt.zsh"
source "$HOME/.zsh/functions.d/find-in-hist.zsh"
source "$HOME/.zsh/functions.d/gerrit.zsh"
source "$HOME/.zsh/functions.d/git.zsh"
source "$HOME/.zsh/functions.d/jenkins.zsh"
source "$HOME/.zsh/functions.d/man.zsh"
source "$HOME/.zsh/functions.d/multicat.zsh"
source "$HOME/.zsh/functions.d/pickle.zsh"
source "$HOME/.zsh/functions.d/print.zsh"
source "$HOME/.zsh/functions.d/proxy.zsh"
source "$HOME/.zsh/functions.d/randstr.zsh"
source "$HOME/.zsh/functions.d/slurm.zsh"
source "$HOME/.zsh/functions.d/spack.zsh"
source "$HOME/.zsh/functions.d/tmux.zsh"
source "$HOME/.zsh/functions.d/vim.zsh"
source "$HOME/.zsh/functions.d/whatwhen.zsh"

get-modeline() {
    cvt $1 $2 $3 | grep Modeline | sed -e "s/Modeline\s//"
}

startx-wifi() {
    # start the xserver with a given wifi profile
    sudo netctl start "${1}" &; startx 
}

get_bpm() {
    sox "$1" -t raw -r 44100 -e float -c 1 - | bpm -x ${max_bpm:-190}
}

# Usage:
#    targrepl <pattern> <tarfile>
#
# Prints all files matching <pattern> in <tarfile>. Just like `grep -l` does
# for normal files.
targrepl() {
    local pattern="$1"
    local tarfile="$2"
    tar Pxf "${tarfile}" --to-command "awk '/${pattern}/ { print ENVIRON[\"TAR_FILENAME\"]; exit }'"
}

export_terminfo_alacritty() {
    if (( $# == 0 )); then
        espackcho "Need to specify host" >&2
        return
    fi
    local host="$1"
    if (( $( find /usr/share/terminfo/a -type f -name "alacritty*" | wc -l) )); then
        tar c /usr/share/terminfo/a/alacritty*  | ssh "${host}" "([ ! -d .terminfo/a ] && mkdir -vp .terminfo/a) && cd .terminfo/a && tar vx -f - --strip-components=4"
    else
        echo "Error: Alacritty terminfo not found!" >&2
    fi
}

# Usage:
#   host_to_ip <hostname>
#
# Prints the ip of the given hostname.
host_to_ip() {
    getent hosts "$1" | cut -d ' ' -f 1
}

# Usage:
#   wait_pid [-i <interval>] <pid>
#
# Wait for the given PID in intervals of length <interval>s.
wait_pid() {
    local pid
    local interval
    interval=1
    while getopts ":i:" opts; do
        case "${opts}" in
            i)
                interval="${OPTARG}"
                ;;
            *)
                echo "Invalid argument: ${opts}" >&2
                return 1
                ;;
        esac
    done
    shift $(( OPTIND - 1 ))
    if (( $# > 0 )); then
        pid="$1"
    else
        echo "No PID given.." >&2
        return 1
    fi
    echo -n "Waiting for PID: ${pid}" >&2

    while kill -0 ${pid} 2>/dev/null 1>/dev/null; do
        echo -n "."
        sleep "${interval}"
    done
}

# fzf-fasd integration
#
# Interactively insert recent directory
zd() {
    fasd -d -l -r "$1" | fzf --query="$1 " --select-1 --exit-0 --height=25% --reverse --tac --no-sort --cycle
}

# vim: ft=zsh
