source "$HOME/.zsh/functions.d/conversion.zsh"
source "$HOME/.zsh/functions.d/find-in-hist.zsh"
source "$HOME/.zsh/functions.d/gerrit.zsh"
source "$HOME/.zsh/functions.d/man.zsh"
source "$HOME/.zsh/functions.d/multicat.zsh"
source "$HOME/.zsh/functions.d/pickle.zsh"
source "$HOME/.zsh/functions.d/print.zsh"
source "$HOME/.zsh/functions.d/proxy.zsh"
source "$HOME/.zsh/functions.d/randstr.zsh"
source "$HOME/.zsh/functions.d/whatwhen.zsh"

tmux-launch-and-configure() {
    tmux new-session -d -s $1
    tmux source "$HOME/.tmux/$1.conf"
    tmux attach -t $1
}

get-modeline() {
    cvt $1 $2 $3 | grep Modeline | sed -e "s/Modeline\s//"
}

slurm-get-job-ids() {
    if [[ $# > 1 ]]; then
        state=$1
    else
        state="PD"
    fi
    squeue -h | grep obreitwi | grep "\b$state\b" | cut -d " " -f 3
}

# nicer git log
gitlg() {
    PAGER=/usr/bin/less git log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit $@ --
}

_git
compdef __git_branch_names gitlg

uniq_lines() {
    cat -n $1 | sort -uk2 | sort -nk1 | cut -f2-
}

spack_modules() {
    TMPFILE="$(mktemp)"
    for mod in "$@"; do
        (echo "Loading $mod…" 1>&2)
        spack module loads -r $mod >> $TMPFILE
    done
    (echo "Committing…" 1>&2)
    uniq_lines $TMPFILE
    rm $TMPFILE
}

spack_load() {
    source =(spack_modules "$@")
}

gen_ssha512() {
    local pw="$1"
    while [ -z "${pw}" ]; do
        echo -n "Password: "
        read -s pw_1
        echo ""
        echo -n "Password (repeat): "
        read -s pw_2
        echo ""
        if [[ "${pw_1}" = "${pw_2}" ]] && [[ "${pw_2}" = "${pw_2}" ]]; then
            pw="${pw_1}"
        fi
    done
    local salt=$(cat /dev/urandom | head -c 8)
    (
        echo -n "${pw}${salt}" | openssl dgst -sha512 -binary
        echo -n ${salt}
    ) | openssl enc -a -A | awk '{ print "{SSHA512}"$0 }'
}

startx-wifi() {
    # start the xserver with a given wifi profile
    sudo netctl start "${1}" &; startx 
}

# container utility functions
# Usage:
#   launch_container [options] [<app>] [<image>]
launch_container() {
    local image
    local app

    local args
    args=("shell" "-s" "/bin/zsh")

    local getent_home
    getent_home=$(getent passwd $USER | cut -d: -f6)

    # if current $HOME differs from getent value, set it
    if [ "${HOME}" != "${getent_home}" ]; then
        args+=("-H" "${HOME}")
    fi

    args+=("-B" "/run")

    if (( $# > 0 )); then
        app="${1}"
        args+=("--app" "${app}")
        shift
    fi
    image="${1:-$(readlink -f ${MY_DEFAULT_CONTAINER:-/containers/stable/latest})}"

    singularity "${args[@]}" "${image}"
}

alias runcon="launch_container"

condev() {
    launch_container visionary-dev-tools "${@}"
}

conwaf() {
    launch_container visionary-wafer "${@}"
}

condls() {
    launch_container visionary-dls "${@}"
}

jrest() {
    local method
    local url
    local username
    local password
    method=$1
    if [[ "${(U)method}" =~ "^(GET|PUT|POST|DELETE)$" ]]; then
        shift
    else
        # first argument only contains URL
        method=""
    fi
    url=$1
    host="$(jq -r .url ~/.config/jenkins/jenkins.json)"
    username="$(jq -r .username ~/.config/jenkins/jenkins.json)"
    token="$(jq -r .token ~/.config/jenkins/jenkins.json)"
    shift
    http --auth-type basic                                                   \
         --auth "${username}:${token}"                                       \
         ${method}                                                           \
         ${host}${url}                                                       \
         "${@}"
}

# Usage:
#   jenkins_get_log [-a <artifact>] <project>[/][<build number>]
#
#   Fetches and echoes the name of the file in which the log is present. Log
#   will only be fetched if logfile does not exist.
#
#   Can then be used like this: nvim $(jenkins_get_log my-fancy-jobname).
#
#   See also: jenkins_view_log
#
# Args:
#   -a <artifact>   Get specific artifact (example: errors_concretization.log).
#
#   -f              Force redownload of log even if it exists.
#
#   <project>       Project to fetch
#
#   <build number>  Log from which build to get [default: latest]. Can be set
#                   to -n to get the n-th latest build log.
#
jenkins_get_log() {
    local project
    local build_num
    local logname
    local artifact
    local force
    local latest_build
    local opts OPTIND OPTARG
    artifact=""
    force=0

    while getopts ":a:f" opts; do
        case "${opts}" in
            a)
                artifact="${OPTARG}"
                ;;
            f)  force=1
                ;;
            *)
                echo "Invalid argument: ${opts}" >&2
                return 1
                ;;
        esac
    done
    shift $(( OPTIND - 1 ))

    if (( $# > 0 )); then
        local proj_arr
        proj_arr=( "${(s./.)1}" )
        project="${proj_arr[1]}"
        if (( ${#proj_arr} > 1 )); then
            build_num="${proj_arr[2]}"
        fi
    else
        echo "Need to specify project!" &>2
        return 1
    fi
    shift

    if (( $# > 0 )); then
        build_num="$1"
        shift
    fi

    if [ -n "${build_num:-}" ]; then
        if (( build_num <= 0 )); then
            latest_build=$(jrest GET /job/${project}/api/json | jq ".builds | .[0] | .number")
            build_num=$(( latest_build + build_num ))
        fi
    else
        build_num=$(jrest GET /job/${project}/api/json | jq ".builds | .[0] | .number")
    fi
    if (( ${#artifact} > 0 )); then
        logname="${TMPDIR:-/tmp}/${project}_${build_num}_${artifact}"
    else
        logname="${TMPDIR:-/tmp}/${project}_${build_num}.log"
    fi

    if [ ! -f "${logname}" ] || (( force != 0 )); then
        if (( ${#artifact} > 0 )); then
            jrest GET "/job/${project}/${build_num}/artifact/${artifact}" > "${logname}" || rm ${logname}
        else
            jrest GET "/job/${project}/${build_num}/consoleText" > "${logname}"
        fi
    fi
    echo "${logname}"
}

# Usage:
#   jenkins_view_log [-a <artifact>] <project>[/][<build number>]
#
#   Fetches and opens the specified jenkins log in $EDITOR. Log will only be
#   fetched if logfile does not exist.
#
# Args:
#   -a <artifact>   Get specific artifact (example: errors_concretization.log).
#
#   -f              Force redownload of log even if it exists.
#
#   <project>       Project to fetch
#
#   <build number>  Log from which build to get [default: latest]. Can be set
#                   to -n to get the n-th latest build log.
#
jenkins_view_log() {
    ${EDITOR} $(jenkins_get_log "${@}")
}

gerrit_get_changes() {
    grest "/a/changes/?q=$*"  | tail -n +2 | jq -r "map(.id) | .[]"
}

clang_format_head() {
    file_list=("${(@f)$(git diff-tree ${1:-HEAD} --no-commit-id --name-only -r \
        | grep "\.\(c\|cpp\|tcc\|h\|hpp\)$" \
        | xargs ls -d 2>/dev/null \
        )}")
    clang-format -i "${file_list[@]}"
    sed -i "s:^\(} // namespace .*\)GENPYBIND_TAG_.*$:\1:" "${file_list[@]}"
    git status
}

gerrit_change_id_head()
{
    git log -n 1 | awk '$1 ~ /Change-Id:/ { print $2 }' | tr -d '\n'
}

# Post a message (-m) to the given change_id (-c)
#
# If change id is not specified, take the current head.
#
# Args:
#   -c change_id
#   -l labels
#   -m message
gerrit_post_message() {
    local change_id
    local message
    local labels
    local -a args
    local opts OPTIND OPTARG
    change_id="head"
    message=""
    while getopts ":c:l:m:" opts; do
        case "${opts}" in
            c)
                change_id="${OPTARG}"
                ;;
            m)  message="${OPTARG}"
                ;;
            l)  labels="${OPTARG}"
                ;;
            t)  topic="${OPTARG}"
                ;;
            *)
                echo "Invalid argument: ${opts}" >&2
                return 1
                ;;
        esac
    done
    shift $(( OPTIND - 1 ))

    if [ "${change_id}" = "head" ]; then
        change_id="$(gerrit_change_id_head)"
    fi

    args=( POST "/a/changes/${change_id}/revisions/current/review" )

    if [ -n "${message}" ]; then
        args+=( "message=${message}" )
    fi

    if [ -n "${labels}" ]; then
        args+=( "labels:=${labels}" )
    fi

    grest "${args[@]}"
}

# Set a topic (-t) on the given change_id (-c)
#
# If change id is not specified, take the current head.
#
# Args:
#   -c change_id
#   -t topic
gerrit_set_topic() {
    local change_id
    local topic
    local -a args
    local opts OPTIND OPTARG
    change_id="head"
    message=""
    while getopts ":c:t:" opts; do
        case "${opts}" in
            c)
                change_id="${OPTARG}"
                ;;
            t)  topic="${OPTARG}"
                ;;
            *)
                echo "Invalid argument: ${opts}" >&2
                return 1
                ;;
        esac
    done
    shift $(( OPTIND - 1 ))

    if [ "${change_id}" = "head" ]; then
        change_id="$(gerrit_change_id_head)"
    fi

    args=( PUT "/a/changes/${change_id}/topic" )

    if [ -n "${topic}" ]; then
        args+=( "topic=${topic}" )
    else
        echo "ERROR: -t not provided!" >&2
        exit 1
    fi

    grest "${args[@]}"
}

# Modify hashtags on the given change_id (-c)
#
# If change id is not specified, take the current head.
#
# Args:
#   -c change_id
#   [-a <hashtag to add>...]
#   [-r <hashtag to remove>...]
gerrit_hashtags() {
    local change_id
    local -a add
    local -a remove
    local -a args
    local opts OPTIND OPTARG
    change_id="head"
    while getopts ":c:a:r:" opts; do
        case "${opts}" in
            c)
                change_id="${OPTARG}"
                ;;
            a)  add+=("${OPTARG}")
                ;;
            r)  remove=+("${OPTARG}")
                ;;
            *)
                echo "Invalid argument: ${opts}" >&2
                return 1
                ;;
        esac
    done
    shift $(( OPTIND - 1 ))

    if [ "${change_id}" = "head" ]; then
        change_id="$(gerrit_change_id_head)"
    fi

    args=( POST "/a/changes/${change_id}/hashtags" )

    if [ -n "${add[*]}" ] && [ -n "${remove[*]}" ]; then
        echo "ERROR: No hashtags given." >&2
        exit 1
    fi

    if [ -n "${add[*]}" ]; then
        local add_inner="$(printf '"%s", ' "${add[@]}")"
        args+=( "add:=[${add_inner%%, }]" )
    fi

    if [ -n "${remove[*]}" ]; then
        local remove_inner="$(printf '"%s", ' "${remove[@]}")"
        args+=( "remove:=[${remove_inner%%, }]" )
    fi

    grest "${args[@]}"
}

gerrit_build_this() {
    gerrit_post_message -m "BUILD_THIS"
}

get_bpm() {
    sox "$1" -t raw -r 44100 -e float -c 1 - | bpm -x ${max_bpm:-190}
}

nv() {
    neovide "${@}" &|
}

# Usage:
#    targrepl <pattern> <tarfile>
#
# Prints all files matching <pattern> in <tarfile>. Just like `grep -l` does
# for normal files.
targrepl() {
    local pattern="$1"
    local tarfile="$2"
    tar Pxf "${tarfile}" --to-command "awk '/${pattern}/ { print ENVIRON[\"TAR_FILENAME\"]; exit }'"
}

export_terminfo_alacritty() {
    if (( $# == 0 )); then
        echo "Need to specify host" >&2
        return
    fi
    local host="$1"
    if (( $( find /usr/share/terminfo/a -type f -name "alacritty*" | wc -l) )); then
        tar c /usr/share/terminfo/a/alacritty*  | ssh "${host}" "([ ! -d .terminfo/a ] && mkdir -vp .terminfo/a) && cd .terminfo/a && tar vx -f - --strip-components=4"
    else
        echo "Error: Alacritty terminfo not found!" >&2
    fi
}

# Usage:
#   host_to_ip <hostname>
#
# Prints the ip of the given hostname.
host_to_ip() {
    getent hosts "$1" | cut -d ' ' -f 1
}

# Usage:
#   wait_pid [-i <interval>] <pid>
#
# Wait for the given PID in intervals of length <interval>s.
wait_pid() {
    local pid
    local interval
    interval=1
    while getopts ":i:" opts; do
        case "${opts}" in
            i)
                interval="${OPTARG}"
                ;;
            *)
                echo "Invalid argument: ${opts}" >&2
                return 1
                ;;
        esac
    done
    shift $(( OPTIND - 1 ))
    if (( $# > 0 )); then
        pid="$1"
    else
        echo "No PID given.." >&2
        return 1
    fi
    echo -n "Waiting for PID: ${pid}" >&2

    while kill -0 ${pid} 2>/dev/null 1>/dev/null; do
        echo -n "."
        sleep "${interval}"
    done
}

gerrit_checkout() {
    changenum="$(git review -l | grep "^\s*[0-9]" | fzf | awk '{ print $1 }')"

    if [ -n "${changenum}" ]; then
        git review -d "${changenum}"
    fi
}

gerrit_cherrypick() {
    changenums=( "${(@f)$(git review -l | grep "^\s*[0-9]" | fzf --multi | awk '{ print $1 }')}" )

    for num in "${changenums[@]}"; do
        if [ -n "${num}" ]; then
            git review -x "${num}" || return 1
        fi
    done
}

# fzf-fasd integration
#
# Interactively insert recent directory
zd() {
    fasd -d -l -r "$1" | fzf --query="$1 " --select-1 --exit-0 --height=25% --reverse --tac --no-sort --cycle
}

# vim: ft=zsh
