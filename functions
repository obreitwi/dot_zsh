
source "$HOME/.zsh/functions.d/multicat.zsh"
source "$HOME/.zsh/functions.d/pklopen.zsh"
source "$HOME/.zsh/functions.d/print.zsh"
source "$HOME/.zsh/functions.d/proxy.zsh"
source "$HOME/.zsh/functions.d/randstr.zsh"
source "$HOME/.zsh/functions.d/vman.zsh"
source "$HOME/.zsh/functions.d/whatwhen.zsh"


find_in_hist() {
    zgrep -i "$1" ~/.logs/*.gz
    grep -ri "$1" ~/.logs
}
alias fih=find_in_list

tmux-launch-and-configure() {
    tmux new-session -d -s $1
    tmux source "$HOME/.tmux/$1.conf"
    tmux attach -t $1
}

get-modeline() {
    cvt $1 $2 $3 | grep Modeline | sed -e "s/Modeline\s//"
}

slurm-get-job-ids() {
    if [[ $# > 1 ]]; then
        state=$1
    else
        state="PD"
    fi
    squeue -h | grep obreitwi | grep "\b$state\b" | cut -d " " -f 3
}

# nicer git log
gitlg() {
    PAGER=/usr/bin/less git log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit $@ --
}

_git
compdef __git_branch_names gitlg

heic_to_jpg() {
    for origin in "$@"; do
        extension=${origin:e}
        if [[ "${extension:l}" != "heic" ]]; then
            echo "Wrong extension: ${origin}" >&2
        else
            target="${origin:r}.jpg"
            tifig -v -p -q 95 -i ${origin} -o ${target}
        fi
    done
}

svg_to_pdf() {
    for origin in "$@"; do
        extension=${origin:e}
        if [[ "$extension" != "svg" ]]; then
            echo "Wrong extension: ${origin}" >&2
        else
            target="${origin:r}.pdf"
            inkscape --export-filename="${target}" --export-dpi=600 --export-area-page  "${origin}"
        fi
    done
}

svg_to_png() {
    for origin in "$@"; do
        extension=${origin:e}
        if [[ "$extension" != "svg" ]]; then
            echo "Wrong extension: ${origin}" >&2
        else
            target="${origin:r}.png"
            inkscape --export-filename="${target}" --export-dpi=600 --export-area-page "${origin}"
        fi
    done
}

svg_to_pdf_rsvg() {
    for origin in "$@"; do
        extension=${origin:e}
        if [[ "$extension" != "svg" ]]; then
            echo "Wrong extension: ${origin}" >&2
        else
            target="${origin:r}.pdf"
            rsvg-convert -f pdf --output "${target}" --dpi-x 600 --dpi-y 600 "${origin}"
        fi
    done
}

svg_to_png_rsvg() {
    for origin in "$@"; do
        extension=${origin:e}
        if [[ "$extension" != "svg" ]]; then
            echo "Wrong extension: ${origin}" >&2
        else
            target="${origin:r}.png"
            rsvg-convert -f png --output "${target}" --dpi-x 600 --dpi-y 600 "${origin}"
        fi
    done
}

# see https://trac.ffmpeg.org/wiki/Encode/MP3
to_mp3() {
    for origin in "$@"; do
        ffmpeg -i "${origin}" -vn -acodec libmp3lame -ac 2 -aq ${AQ:-2} -ar 48000 "${origin:t:r}.mp3"
    done
}

get_eta() {
    for f in "$@"; do
        grep "ETA" $f | tail -n 1
    done
}

uniq_lines() {
    cat -n $1 | sort -uk2 | sort -nk1 | cut -f2-
}

spack_modules() {
    TMPFILE="$(mktemp)"
    for mod in "$@"; do
        (echo "Loading $mod…" 1>&2)
        spack module loads -r $mod >> $TMPFILE
    done
    (echo "Committing…" 1>&2)
    uniq_lines $TMPFILE
    rm $TMPFILE
}

eg () {
        (( $+1 )) || {
                cat >&2 <<END
Usage: $0 [<args>...] [<expr>]

  args: Arguments to pass to man.
  expr: Command line argument to search for.
        Defaults to jump to the "EXAMPLE" section.

Examples:

  $0 find
  $0 less -s
  $0 1 less -s
  $0 zshall HIST_IGNORE_SPACE
  $0 zshall fc
END
                return 1
        }
        local expr='^EXAMPLE'
        local -a args
        args=("$@")
        (( $+2 )) && {
                expr="^[[:blank:]]*${@[-1]}"
                args=("${@[1,-2]}")
        }
        PAGER="less -g -s '+/$expr'" man "${=args}"
}

spack_load() {
    source =(spack_modules "$@")
}

cat_pkl() {
    for f in "$@"; do
        python -c "import cPickle as pkl, pprint; pprint.pprint(pkl.load(open('${f}', 'r')))"
    done
}

# Fetch all open changesets and assign them their own branch:
# gerrit_tree_view/{change number}/{patchset level}
gerrit_fetch_changesets() {
    git_dir="$(git rev-parse --show-toplevel)"
    # remote branch
    gerrit_remote="$(grep "^defaultremote=" "${git_dir}/.gitreview" | cut -d = -f 2)"
    localbranchname=gerrit_tree_view

    gerrit_remote_raw=$(git config --local remote.${gerrit_remote}.url)
    elements=("${(@s:/:)gerrit_remote_raw}")
    gerrit_project=${elements[-1]}
    elements[-1]=()
    gerrit_url=${(j./.)elements}

    elements=("${(@s.:.)gerrit_url}")
    gerrit_port=${elements[-1]}
    gerrit_url=${${elements[-2]}:gs./.}

    git branch -D $(git branch | grep "$localbranchname") &> /dev/null
    ssh -p ${gerrit_port} ${gerrit_url} gerrit query "project:${gerrit_project} status:open" --current-patch-set | sed -n 's/\s*ref: //p' | while read REF
do
    git fetch "${gerrit_remote}" "${REF}"
    git branch $(echo "${REF}" | sed "s#refs/changes/../#${localbranchname}/#") FETCH_HEAD
done
}

gerrit_query() {
    local git_dir gerrit_branch gerrit_remote gerrit_host gerrit_port gerrit_project

    git_dir="$(git rev-parse --show-toplevel)"

    gerrit_branch="$(grep "^defaultbranch=" "${git_dir}/.gitreview" | cut -d = -f 2)"
    gerrit_remote="$(grep "^defaultremote=" "${git_dir}/.gitreview" | cut -d = -f 2)"
    gerrit_host="$(grep "^host=" "${git_dir}/.gitreview" | cut -d = -f 2)"
    gerrit_port="$(grep "^port=" "${git_dir}/.gitreview" | cut -d = -f 2)"
    gerrit_project="$(grep "^project=" "${git_dir}/.gitreview" | cut -d = -f 2)"

    ssh -p ${gerrit_port} ${gerrit_host} gerrit query "${@}"
}

# Get current change ids
#
# Usage:
#   gerrit_current_change_ids [-b <base-commit>]
#
#   -b defaults to remote head
gerrit_current_change_ids() {
    git_dir="$(git rev-parse --show-toplevel)"
    local base_commit=""

    local opts OPTIND OPTARG
    while getopts ":b:" opts; do
        case "${opts}" in
            b)
                base_commit="${OPTARG}"
                ;;
            *)
                echo "Invalid argument: ${opts}" >&2
                return 1
                ;;
        esac
    done
    shift $(( OPTIND - 1 ))

    if [ -z "${base_commit}" ]; then
        # remote branch
        gerrit_branch="$(grep "^defaultbranch=" "${git_dir}/.gitreview" | cut -d = -f 2)"
        gerrit_remote="$(grep "^defaultremote=" "${git_dir}/.gitreview" | cut -d = -f 2)"

        gerrit_remote_raw=$(git config --local remote.${gerrit_remote}.url)
        elements=("${(@s:/:)gerrit_remote_raw}")
        gerrit_project=${elements[-1]}
        elements[-1]=()
        gerrit_url=${(j./.)elements}

        elements=("${(@s.:.)gerrit_url}")
        gerrit_port=${elements[-1]}
        gerrit_url=${${elements[-2]}:gs./.}

        base_commit="${gerrit_remote}/${gerrit_branch}"
    fi
    change_ids=( "${(@f)$(git log ${base_commit}..HEAD \
        | awk '$1 ~ /^Change-Id:/ { print $2 }')}" )

    printf "%s\n" "${change_ids[@]}"
}

# Check if the last patch level of any open changeset was last uploaded by someone else.
#
# This should make it harder to accidentally overwrite other peoples edits.
gerrit_check_pre_review() {
    git_dir="$(git rev-parse --show-toplevel)"
    # remote branch
    gerrit_branch="$(grep "^defaultbranch=" "${git_dir}/.gitreview" | cut -d = -f 2)"
    gerrit_remote="$(grep "^defaultremote=" "${git_dir}/.gitreview" | cut -d = -f 2)"

    gerrit_remote_raw=$(git config --local remote.${gerrit_remote}.url)
    elements=("${(@s:/:)gerrit_remote_raw}")
    gerrit_project=${elements[-1]}
    elements[-1]=()
    gerrit_url=${(j./.)elements}

    elements=("${(@s.:.)gerrit_url}")
    gerrit_port=${elements[-1]}
    gerrit_url=${${elements[-2]}:gs./.}
    change_ids=( "${(@f)$(gerrit_current_change_ids)}" )
    committers=( "${(@f)$(git log --format="%cn <%ce>" "${gerrit_remote}/${gerrit_branch}..HEAD")}" )

    if (( ${#change_ids} != ${#committers} )); then
        echo "Not all commits in question have Change-Ids!" >&2
        return 1
    fi

    gerrit_username="${${gerrit_url##ssh://}%%@*}"

    tmpfile_change_info="$(mktemp)"

    for ((i = 1; i <= ${#change_ids}; i++)); do
        change_id="${change_ids[$i]}"
        committer="${committers[$i]}"

        ssh -p ${gerrit_port} ${gerrit_url} \
            "gerrit query project:${gerrit_project} change:${change_id} status:open --current-patch-set --format JSON" \
            | head -n 1 > "${tmpfile_change_info}"
        uploader_name="$(jq -r ".currentPatchSet.uploader.name" < "${tmpfile_change_info}")"
        uploader_mail="$(jq -r ".currentPatchSet.uploader.email" < "${tmpfile_change_info}")"
        change_url="$(jq -r ".url" < "${tmpfile_change_info}")"

        uploader="${uploader_name} <${uploader_mail}>"

        if [[ "${uploader}" == "null <null>" ]]; then
            echo "WARNING: Info on changeset ${change_id} not current anymore! Fetch from review!" >&2
        fi

        if [[ "${committer}" != "${uploader}" ]]; then
            echo "WARNING: [${change_url}] Committers differ! Local: ${committer} / Gerrit: ${uploader}" >&2
        fi
    done
    rm "${tmpfile_change_info}"
}

gen_ssha512() {
    local pw="$1"
    while [ -z "${pw}" ]; do
        echo -n "Password: "
        read -s pw_1
        echo ""
        echo -n "Password (repeat): "
        read -s pw_2
        echo ""
        if [[ "${pw_1}" = "${pw_2}" ]] && [[ "${pw_2}" = "${pw_2}" ]]; then
            pw="${pw_1}"
        fi
    done
    local salt=$(cat /dev/urandom | head -c 8)
    (
        echo -n "${pw}${salt}" | openssl dgst -sha512 -binary
        echo -n ${salt}
    ) | openssl enc -a -A | awk '{ print "{SSHA512}"$0 }'
}

startx-wifi() {
    # start the xserver with a given wifi profile
    sudo netctl start "${1}" &; startx 
}

# container utility functions
# Usage:
#   launch_container [options] [<app>] [<image>]
launch_container() {
    local image
    local app

    local args
    args=("shell" "-s" "/bin/zsh")

    local getent_home
    getent_home=$(getent passwd $USER | cut -d: -f6)

    # if current $HOME differs from getent value, set it
    if [ "${HOME}" != "${getent_home}" ]; then
        args+=("-H" "${HOME}")
    fi

    args+=("-B" "/run")

    if (( $# > 0 )); then
        app="${1}"
        args+=("--app" "${app}")
        shift
    fi
    image="${1:-$(readlink -f ${MY_DEFAULT_CONTAINER:-/containers/stable/latest})}"

    singularity "${args[@]}" "${image}"
}

alias runcon="launch_container"

condev() {
    launch_container visionary-dev-tools "${@}"
}

conwaf() {
    launch_container visionary-wafer "${@}"
}

condls() {
    launch_container visionary-dls "${@}"
}

gerrit() {
  ssh -p $(jq -r .port ~/.config/gerrit/gerrit.json) \
      -l $(jq -r .username ~/.config/gerrit/gerrit.json) \
      $(jq -r .host.ssh ~/.config/gerrit/gerrit.json) gerrit "${@}"
}


# gerrit rest api access
# first argument an be used to specify the method, if it is not GET POST or PUT
# it will be interpreted as URL
grest() {
    local host
    local method
    local url
    local username
    local password
    method=$1
    if [[ "${(U)method}" =~ "^(GET|PUT|POST|DELETE)$" ]]; then
        shift
    else
        # first argument only contains URL
        method=""
    fi
    url=$1
    host="$(jq -r .host.web ~/.config/gerrit/gerrit.json)"
    username="$(jq -r .username ~/.config/gerrit/gerrit.json)"
    password="$(jq -r .password ~/.config/gerrit/gerrit.json)"
    shift
    http --auth-type basic                                                    \
         --auth "${username}:${password}"                                     \
         ${method}                                                            \
         ${host}${url}                                                        \
         "${@}"
}

jrest() {
    local method
    local url
    local username
    local password
    method=$1
    if [[ "${(U)method}" =~ "^(GET|PUT|POST|DELETE)$" ]]; then
        shift
    else
        # first argument only contains URL
        method=""
    fi
    url=$1
    host="$(jq -r .url ~/.config/jenkins/jenkins.json)"
    username="$(jq -r .username ~/.config/jenkins/jenkins.json)"
    token="$(jq -r .token ~/.config/jenkins/jenkins.json)"
    shift
    http --auth-type basic                                                   \
         --auth "${username}:${token}"                                       \
         ${method}                                                           \
         ${host}${url}                                                       \
         "${@}"
}

# Usage:
#   jenkins_get_log [-a <artifact>] <project>[/][<build number>]
#
#   Fetches and echoes the name of the file in which the log is present. Log
#   will only be fetched if logfile does not exist.
#
#   Can then be used like this: nvim $(jenkins_get_log my-fancy-jobname).
#
#   See also: jenkins_view_log
#
# Args:
#   -a <artifact>   Get specific artifact (example: errors_concretization.log).
#
#   -f              Force redownload of log even if it exists.
#
#   <project>       Project to fetch
#
#   <build number>  Log from which build to get [default: latest]. Can be set
#                   to -n to get the n-th latest build log.
#
jenkins_get_log() {
    local project
    local build_num
    local logname
    local artifact
    local force
    local latest_build
    local opts OPTIND OPTARG
    artifact=""
    force=0

    while getopts ":a:f" opts; do
        case "${opts}" in
            a)
                artifact="${OPTARG}"
                ;;
            f)  force=1
                ;;
            *)
                echo "Invalid argument: ${opts}" >&2
                return 1
                ;;
        esac
    done
    shift $(( OPTIND - 1 ))

    if (( $# > 0 )); then
        local proj_arr
        proj_arr=( "${(s./.)1}" )
        project="${proj_arr[1]}"
        if (( ${#proj_arr} > 1 )); then
            build_num="${proj_arr[2]}"
        fi
    else
        echo "Need to specify project!" &>2
        return 1
    fi
    shift

    if (( $# > 0 )); then
        build_num="$1"
        shift
    fi

    if [ -n "${build_num:-}" ]; then
        if (( build_num <= 0 )); then
            latest_build=$(jrest GET /job/${project}/api/json | jq ".builds | .[0] | .number")
            build_num=$(( latest_build + build_num ))
        fi
    else
        build_num=$(jrest GET /job/${project}/api/json | jq ".builds | .[0] | .number")
    fi
    if (( ${#artifact} > 0 )); then
        logname="${TMPDIR:-/tmp}/${project}_${build_num}_${artifact}"
    else
        logname="${TMPDIR:-/tmp}/${project}_${build_num}.log"
    fi

    if [ ! -f "${logname}" ] || (( force != 0 )); then
        if (( ${#artifact} > 0 )); then
            jrest GET "/job/${project}/${build_num}/artifact/${artifact}" > "${logname}" || rm ${logname}
        else
            jrest GET "/job/${project}/${build_num}/consoleText" > "${logname}"
        fi
    fi
    echo "${logname}"
}

# Usage:
#   jenkins_view_log [-a <artifact>] <project>[/][<build number>]
#
#   Fetches and opens the specified jenkins log in $EDITOR. Log will only be
#   fetched if logfile does not exist.
#
# Args:
#   -a <artifact>   Get specific artifact (example: errors_concretization.log).
#
#   -f              Force redownload of log even if it exists.
#
#   <project>       Project to fetch
#
#   <build number>  Log from which build to get [default: latest]. Can be set
#                   to -n to get the n-th latest build log.
#
jenkins_view_log() {
    ${EDITOR} $(jenkins_get_log "${@}")
}

gerrit_get_changes() {
    grest "/a/changes/?q=$*"  | tail -n +2 | jq -r "map(.id) | .[]"
}

clang_format_head() {
    file_list=("${(@f)$(git diff-tree ${1:-HEAD} --no-commit-id --name-only -r \
        | grep "\.\(c\|cpp\|tcc\|h\|hpp\)$" \
        | xargs ls -d 2>/dev/null \
        )}")
    clang-format -i "${file_list[@]}"
    sed -i "s:^\(} // namespace .*\)GENPYBIND_TAG_.*$:\1:" "${file_list[@]}"
    git status
}

gerrit_change_id_head()
{
    git log -n 1 | awk '$1 ~ /Change-Id:/ { print $2 }' | tr -d '\n'
}

# Post a message (-m) to the given change_id (-c)
#
# If change id is not specified, take the current head.
#
# Args:
#   -c change_id
#   -l labels
#   -m message
gerrit_post_message() {
    local change_id
    local message
    local labels
    local -a args
    local opts OPTIND OPTARG
    change_id="head"
    message=""
    while getopts ":c:l:m:" opts; do
        case "${opts}" in
            c)
                change_id="${OPTARG}"
                ;;
            m)  message="${OPTARG}"
                ;;
            l)  labels="${OPTARG}"
                ;;
            t)  topic="${OPTARG}"
                ;;
            *)
                echo "Invalid argument: ${opts}" >&2
                return 1
                ;;
        esac
    done
    shift $(( OPTIND - 1 ))

    if [ "${change_id}" = "head" ]; then
        change_id="$(gerrit_change_id_head)"
    fi

    args=( POST "/a/changes/${change_id}/revisions/current/review" )

    if [ -n "${message}" ]; then
        args+=( "message=${message}" )
    fi

    if [ -n "${labels}" ]; then
        args+=( "labels:=${labels}" )
    fi

    grest "${args[@]}"
}

# Set a topic (-t) on the given change_id (-c)
#
# If change id is not specified, take the current head.
#
# Args:
#   -c change_id
#   -t topic
gerrit_set_topic() {
    local change_id
    local topic
    local -a args
    local opts OPTIND OPTARG
    change_id="head"
    message=""
    while getopts ":c:t:" opts; do
        case "${opts}" in
            c)
                change_id="${OPTARG}"
                ;;
            t)  topic="${OPTARG}"
                ;;
            *)
                echo "Invalid argument: ${opts}" >&2
                return 1
                ;;
        esac
    done
    shift $(( OPTIND - 1 ))

    if [ "${change_id}" = "head" ]; then
        change_id="$(gerrit_change_id_head)"
    fi

    args=( PUT "/a/changes/${change_id}/topic" )

    if [ -n "${topic}" ]; then
        args+=( "topic=${topic}" )
    else
        echo "ERROR: -t not provided!" >&2
        exit 1
    fi

    grest "${args[@]}"
}

# Modify hashtags on the given change_id (-c)
#
# If change id is not specified, take the current head.
#
# Args:
#   -c change_id
#   [-a <hashtag to add>...]
#   [-r <hashtag to remove>...]
gerrit_hashtags() {
    local change_id
    local -a add
    local -a remove
    local -a args
    local opts OPTIND OPTARG
    change_id="head"
    while getopts ":c:a:r:" opts; do
        case "${opts}" in
            c)
                change_id="${OPTARG}"
                ;;
            a)  add+=("${OPTARG}")
                ;;
            r)  remove=+("${OPTARG}")
                ;;
            *)
                echo "Invalid argument: ${opts}" >&2
                return 1
                ;;
        esac
    done
    shift $(( OPTIND - 1 ))

    if [ "${change_id}" = "head" ]; then
        change_id="$(gerrit_change_id_head)"
    fi

    args=( POST "/a/changes/${change_id}/hashtags" )

    if [ -n "${add[*]}" ] && [ -n "${remove[*]}" ]; then
        echo "ERROR: No hashtags given." >&2
        exit 1
    fi

    if [ -n "${add[*]}" ]; then
        local add_inner="$(printf '"%s", ' "${add[@]}")"
        args+=( "add:=[${add_inner%%, }]" )
    fi

    if [ -n "${remove[*]}" ]; then
        local remove_inner="$(printf '"%s", ' "${remove[@]}")"
        args+=( "remove:=[${remove_inner%%, }]" )
    fi

    grest "${args[@]}"
}

gerrit_build_this() {
    gerrit_post_message -m "BUILD_THIS"
}

get_bpm() {
    sox "$1" -t raw -r 44100 -e float -c 1 - | bpm -x ${max_bpm:-190}
}

nv() {
    neovide "${@}" &|
}

# Usage:
#    targrepl <pattern> <tarfile>
#
# Prints all files matching <pattern> in <tarfile>. Just like `grep -l` does
# for normal files.
targrepl() {
    local pattern="$1"
    local tarfile="$2"
    tar Pxf "${tarfile}" --to-command "awk '/${pattern}/ { print ENVIRON[\"TAR_FILENAME\"]; exit }'"
}

export_terminfo_alacritty() {
    if (( $# == 0 )); then
        echo "Need to specify host" >&2
        return
    fi
    local host="$1"
    if (( $( find /usr/share/terminfo/a -type f -name "alacritty*" | wc -l) )); then
        tar c /usr/share/terminfo/a/alacritty*  | ssh "${host}" "([ ! -d .terminfo/a ] && mkdir -vp .terminfo/a) && cd .terminfo/a && tar vx -f - --strip-components=4"
    else
        echo "Error: Alacritty terminfo not found!" >&2
    fi
}

# Usage:
#   host_to_ip <hostname>
#
# Prints the ip of the given hostname.
host_to_ip() {
    getent hosts "$1" | cut -d ' ' -f 1
}

# Usage:
#   wait_pid [-i <interval>] <pid>
#
# Wait for the given PID in intervals of length <interval>s.
wait_pid() {
    local pid
    local interval
    interval=1
    while getopts ":i:" opts; do
        case "${opts}" in
            i)
                interval="${OPTARG}"
                ;;
            *)
                echo "Invalid argument: ${opts}" >&2
                return 1
                ;;
        esac
    done
    shift $(( OPTIND - 1 ))
    if (( $# > 0 )); then
        pid="$1"
    else
        echo "No PID given.." >&2
        return 1
    fi
    echo -n "Waiting for PID: ${pid}" >&2

    while kill -0 ${pid} 2>/dev/null 1>/dev/null; do
        echo -n "."
        sleep "${interval}"
    done
}

gerrit_checkout() {
    changenum="$(git review -l | grep "^\s*[0-9]" | fzf | awk '{ print $1 }')"

    if [ -n "${changenum}" ]; then
        git review -d "${changenum}"
    fi
}

gerrit_cherrypick() {
    changenums=( "${(@f)$(git review -l | grep "^\s*[0-9]" | fzf --multi | awk '{ print $1 }')}" )

    for num in "${changenums[@]}"; do
        if [ -n "${num}" ]; then
            git review -x "${num}" || return 1
        fi
    done
}

# fzf-fasd integration
#
# Interactively insert recent directory
zd() {
    fasd -d -l -r "$1" | fzf --query="$1 " --select-1 --exit-0 --height=25% --reverse --tac --no-sort --cycle
}

# vim: ft=zsh
